---
layout: post
title:  "Loading..."
published: true
---

In the early stages in what we call “the software”, which is what code is going on the units/Raspberry Pi’s, I started from scratch thus putting some puzzle pieces together, from the standard library of Python 3.6 and third party modules that I have used in the past to be more specific. I wanted to explore Rust and Go as well so I kept that in the back of mind if we ever needed it to do anything that was needed.

Firstly, I had never finished a fully fleshed out Python project before. I have various Python projects floating around on my machine at home and they never came to a production state. Now, you’ll find Python projects on GitHub profile page, and I admit that I have finished two of them, being my MikroTik router setup and my read-only FTP server, I have never done any Python projects with classes, attributes, formating, and some module additions crammed into my project. I was very nervous when we as a team came to this conclusion because I have tried to add all this additions before and that project never came to fruition.

Since the Raspberry Pi folk support Python to great lengths, we as a team decided that was going to be my programming language of choice. As stated above, I was nervous. Eventually, I worked on “the software” day in and day out. With the help of the other teams in the same course, including Richie Tarkowski, Noah Osterhout, and Eric Grant, I got this project to a working state and this was the “prototype” state putting in “dummy” temperatures. This was a very rudimentary state to what it is now but it works!

Rust. There’s alot to say about this language. I was never taught this language formally and I had some background this language through a podcast New Rustacean (it’s really cool, I suggest you go check it out) so other than that, I was blind to the language. A textbook definition of Rust is that Rust is a fast, concurrent, memory safe language. With that in mind, there’s a slew of features that comes with the language. However, with features, there comes drawbacks, like steep learning curve and the “borrow checker,” which is for memory safety. With any variable in Rust, they are immutable, which means you can’t change them once they are set. Another drawback is that Rust doesn’t adhere to traditional object-oriented programming practices like C++, Python, Ruby or C#, if you have previously worked in a object-oriented language. These drawbacks made it hard for me to take a hold on the language and craft something with it. However, with enough grit and brute strength of the mind, I created a utility.

The utility I made with Rust was the universally unique identification generation tool. The UUID generation tool was created out of necessity because Jacob and I were having a conversation about how we are going to define each unit uniquely. I mentioned a UUID would solve that problem as it creates a random twenty-six alphanumeric string that’s not reproducible. Thus, the UUID generation tool was born.

JSON files were the serializing format I chose to pass from the Raspberry Pi to the server so the Thresa, the database administrator, can parse said JSON and insert it into the database. My state of my mind through getting objects and attributes serialized into a JSON format went from focused to a complete nightmare. The Python debugger kept on saying that the time and date attributes, because we as a team decided a timestamp was necessary, it was an attribute, not a string. Of course, cursing and swearing at my computer did not solve anything. Although the type change was very simple, it felt like an eternity getting those attributes and objects into a JSON file. It was very rewarding, however. 
